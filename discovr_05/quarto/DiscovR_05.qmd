---
title: "DiscovR_05"
author: "Ferdinand Edward Bitan"
format: 
  html:
    self-contained: true
    theme: darkly
    toc: true
    code-fold: true
knitr: 
  opts_chunk: 
    warning: false
    message: false
editor: visual
---

# DiscovR_05

## Libraries

```{r}
library(tidyverse)
library(here)
```

## Data

```{r}
wish_tib <- here::here("data/jiminy_cricket.csv") |> readr::read_csv()
notebook_tib <- here::here("data/notebook.csv") |> readr::read_csv()
exam_tib <- here::here("data/exam_anxiety.csv") |> readr::read_csv()
```

## Preparing Data

Need to turn categorical variables into factors and set an appropriate baseline category using `forcats::as_factor` and `forcats::fct_relevel`.

```{r}
wish_tib <- wish_tib |>
  dplyr::mutate(
    strategy = forcats::as_factor(strategy),
    time = forcats::as_factor(time) |> forcats::fct_relevel("Baseline")
  )

```

```{r}
notebook_tib <- notebook_tib |>
  dplyr::mutate(
    sex = forcats::as_factor(sex),
    film = forcats::as_factor(film)
  )
```

```{r}
exam_tib <- exam_tib |>
  dplyr::mutate(
    id = forcats::as_factor(id),
    sex = forcats::as_factor(sex)
  )
```

## ggplot2

You begin with some data and you initialize a plot with the `ggplot()` function within which you name the tibble or data frame that you want to use, then you set a bunch of aesthetics using the `aes()` function. Primarily, you name the variable you want plotted on the *x*-axis, the variable for the *y*-axis and any aesthetics that you want to set for the plot using a variable (for example, you might want to vary the colour of bars by levels of a variable.). You then add layers to the plot that control what the plot shows and perhaps adjust the visual properties of the objects on the layer. For example, you might add a layer of dots to show group means, change their appearance to be filled with different colours, then add a layer of error bars on top of them. There are various key concepts that relate to controlling aspects of the layers of the plot:

-   **Geometric objects**: these are objects that represent data. Some examples are dots to represent raw data or a summary such as a mean, lines connecting data points or summarizing data (e.g., a line of best fit, lines connecting group means), error bars, and so on. For example:

    -   `geom_point()` plots data points (by default dots)

    -   `geom_boxplot()` plots boxplots

    -   `geom_histogram()` plots histograms

    -   `geom_errorbar()` plots error bars

    -   `geom_smooth()` plots summary lines (e.g., linear models and splines)

-   **Objects or 'stats'**: there are situations where rather than using a geom function to display the data it is easier to map a summary of the data directly to the plot with various `stat` functions (usually `stat_summary()`). It's a little complex to explain when you use stats instead of geoms, so we'll learn by doing!

-   **Scales**: These control the details of how the data are mapped to their visual objects. For example, you can control what appears on the *x* and *y* axis (i.e. intervals between values) using `scale_x_continuous()` and `scale_y_continuous()`, axis labels are controlled with `labs()`.

-   **Coordinate system**: by default `ggplot2` uses a Cartesian system. We will use `coord_cartesian()` to set the limits of the *x* and *y* axis.

-   **Position adjustments**: sometimes elements of a plot overlap (e.g., lots of data points in the same place). There are various position adjustments that can be useful such as `position_dodge()` which forces objects not to overlap side by side (handy for complex bar charts) and `position_jitter()` which adds a small random adjustment to data points.

-   **Facets**: facets can be used to plot different parts of the data in different panels. For example, if you wanted a plot of data from dogs and a separate plot of the same data for cats and you wanted these plots side by side, you could do this with `facet_wrap()`.

-   **Themes**: There are a number of built in themes that you can apply to your plots. We will use these built-in themes, but occasionally over-ride defaults with the `theme()` function.

Each of the things above is a layer/transparencies that can be added to a plot. There are also **aesthetics**, which control what the things on a layer look like (in other words, their the visual aesthetics). Examples of aesthetics are the fill colour of points and bars, line colours (of linear models, error bars, lines around bars etc.), the shape of data points, the size of data points, the type of line (full, dashed, dotted etc.). These aesthetics can be set directly for an object (e.g., making all data points red) or can be set using a variable (e.g., colouring data points based on whether it came from an experimental or control group).

## Boxplots (Box-whisker plots)

Dreams are good, but a completely blinkered view that they'll come true without any work on your part is not. Imagine I collected some data from 250 people on their level of success using a composite measure involving their salary, quality of life and how closely their life matches their aspirations. This gave me a score from 0 (complete failure) to 100 (complete success). I then implemented an intervention: I told people that for the next 5 years they should either wish upon a star for their dreams to come true or work as hard as they could to make their dreams come true. I measured their success again 5 years later. People were randomly allocated to these two instructions. The data are in wish_tib. The variables are **id** (the person's id), **strategy** (hard work or wishing upon a star), **time** (baseline or 5 years), and **success** (the rating on my dodgy scale).

First, we're going to create a boxplot of the success scores at baseline and after 5 years. To create a boxplot in `ggplot` we use the `geom_boxplot()` function. We've seen that the general setup of a plot uses this command:

```         
ggplot2::ggplot(my_tib, aes(variable_for_x_axis, variable_for_y_axis))
```

Within the `ggplot()` function replace my_tib with the name of the tibble containing the data you want to plot, and within the `aes()` function replace variable_for_x_axis with the name of the variable to be plotted on the *x*-axis (horizontal), and replace variable_for_y_axis with the name of the variable to be plotted on the *y*-axis (vertical).

-   `wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))` creates an object called wish_plot that contains the plot. The `ggplot()` function is then used to specify that the plot uses the data in the wish_tib tibble and plots the variable **time** on the *x*-axis and the variable **success** on the *y*-axis.

-   `wish_plot + geom_boxplot()` takes the object wish_plot and adds a boxplot geom to it.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  geom_boxplot()
```

Use labs to give axis titles

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  geom_boxplot() + 
  labs(x = "Time", y = "Success (%)") +
  theme_minimal()
```

### Grouping by Colour

The boxplot we have created shows how success changed over time, but it doesn't show us what effect wishing on a star had compared to hard work. We can see this by splitting the data by the variable **strategy**. We can do this in several ways. First, we can ask `ggplot` to vary the fill of the boxes or the colour of the lines around the boxes by the variable **strategy** by adding it to the `aes()` function in the original command to set up the plot For example, to vary the fill of the boxplots by **strategy**, we'd change the first line of our command to be:

```         
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, fill = strategy))
```

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, fill = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)") +
  theme_minimal()
```

Instead of using fill to differentiate the two **strategy** groups, we can use colour. This leaves the boxes white for all groups, but uses different colours for the lines around the boxes.

```         
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
```

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)") +
  theme_minimal()
```

To specify the label for the variable that is used to determine the fill or colour of the plot, we add it to the `labs()` function. For example, if we used **strategy** to determine the fill of the plot then we'd add fill = "label", where *label* is the text we want to use:

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, fill = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)", fill = "Success strategy") +
  theme_minimal()
```

Similarly, if we had used **strategy** to determine the colour of the plot then we'd add colour = "label" to the function

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  theme_minimal()
```

### Grouping using facet_wrap()

A second way to split the data is to add a facet layer, for example, by adding `facet_wrap()` to the plot. This function takes the general form:

```         
facet_wrap(facet, nrow = NULL, ncol = NULL, scales = "fixed")
```

-   facet specifies how you want to create the facet. To create separate plots for the wish upon a star and hard work groups our facet would be \~strategy.

-   nrow specifies how many rows of plots to display. There is no default, the function just tries to make sensible choices. If we wanted the wish upon a star and hard work plots side by side we want them arranged in 1 row, so we could be explicit and include the command nrow = 1.

-   ncol specifies how many columns of plots to display. Again, the function tries to make sensible choices. If we wanted the wish upon a star and hard work plots on top of each other then we want them arranged in 1 column, so we could be explicit and include the command ncol = 1. In reality nrow and ncol become important when you have lots of plots to arrange. For example if you were plotting data from 12 different groups, you might want these arranged in 2 rows and 6 columns, 4 rows and 3 columns, 6 rows and two columns and so on.

-   scales. By default the scales of the plots are set to be the same ("fixed") but sometimes it's handy to let them vary across different plots, in which case set scales = "free" or use "free_x" or "free_y" to allow only the *x*-axis or *y*-axis to vary across plots.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)") +
  facet_wrap(~strategy) + 
  theme_minimal()
```

If wanted to be in columns instead

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)") +
  facet_wrap(~strategy, ncol = 1) +
  theme_minimal()
```

## Plotting Means

Plotting means is slightly more tricky. If you want to plot from the raw data (rather than a tibble containing the summary information) then your best bet is to use the `stat_summary()` function and then specify the geom to use within it. Let's begin by plotting the mean **success** split by **time**. We can do this by setting up the plot exactly as we did for the boxplot, but instead of using `geom_boxplot()` we use:

```         
stat_summary(fun = "mean", geom = "point", size = 4)
```

In the `stat_summary()` function, we're asking  to calculate the means (fun = "mean"). The argument geom = "point" asks `ggplot2` to display the means as dots using `geom_point()`. The final argument, size = 4, determines the size of the dots and overrides the default 

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4) +  
  labs(x = "Time", y = "Success (%)") +
  theme_minimal()
```

### Adjusting the Scales

The plot we've just produced is all well and good, but `ggplot` has scaled the *y*-axis from 50 to 58 and has displayed breaks at the values 50, 52, 54, and 56. This maximizes the differences between means - the small difference looks huge. We shouldn't do this. There's two functions that we can use to add layers that control the scale of the axis.

#### **coord_cartesian()**

```         
coord_cartesian(ylim = c(lower_limit, upper_limit), xlim = c(lower_limit, upper_limit))
```

This code adjusts the *y*-axis and *x*-axis to display values from lower_limit to upper_limit. You would replace each lower_limit and upper_limit with relevant numbers. We want to change only the *y*-axis so we'll ignore xlim for now. If we our *y*-axis to display values from 0 to 100 (the full range of the scale) we would add to the plot:

```         
coord_cartesian(ylim = c(0, 100))
```

#### **scale_y_continuous()**

```         
scale_y_continuous(breaks = seq(lower_limit, upper_limit, increment))
```

I've used the function `seq()` which takes the form

```         
seq(lower_limit, upper_limit, increment)
```

where lower_limit is the value you want to start at, upper_limit is the value you want to stop at, and increment is the size of the increment you want. For example, if we wanted breaks to be displayed at 0, 10, 20, 30 and so on up to 100, we'd specify `seq(0, 100, 10)` which will create a sequence from 0 to 100 in intervals of 10. There is a similar function `scale_x_continuous()` for changing the *x*-axis.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4) +  
  labs(x = "Time", y = "Success (%)") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

### Grouping Means

Just like with boxplots we can also group means by the success strategy used using the same methods. For example, we can add `facet_wrap(~strategy)` to display the two strategies as different panels.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4) +  
  labs(x = "Time", y = "Success (%)") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  facet_wrap(~strategy) +
  theme_minimal()
```

Instead of using facets, we can display the two strategies in different colours, like we did for boxplots. To do this we need to make the same two adjustments to our code to earlier on:

-   Add colour = strategy to the first line, within `aes()`.

-   Add colour = "Success strategy" to the `labs()` function to apply a meaningful label to the variable **strategy**.

*The dots at baseline overlap.*

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4) +  
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

### Adjusting the Positions of Geoms

The `stat_summary()` function (and most geoms) have a position argument that can be set using the function position_dodge(width = value). This function plots geoms so that they 'dodge' each other on the horizontal plane.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4, position = position_dodge(width = 0.4)) +  
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

## Violin Plots

As well plotting the mean success score across the various times and groups, it's also useful to plot the distribution of scores around that mean. We can do that using a violin plot. We can add a 'violin' using the `geom_violin()` function. 

This is the correct way to do it.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
geom_violin() +
  stat_summary(fun = "mean", geom = "point", size = 4, position = position_dodge(width = 0.9)) +  
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

Adding it below the stat_summary fills the dots with the white fill of the violin plots as objects in R are layered on top of each other.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4, position = position_dodge(width = 0.9)) +
  geom_violin() +
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

Alpha values which set transparency can be used to make the dots visible in the second example.

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  stat_summary(fun = "mean", geom = "point", size = 4, position = position_dodge(width = 0.9)) +
  geom_violin(alpha = 0.6) +
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

## Confidence Intervals

The mean in the sample is an estimate, and estimates have uncertainty attached to them. It's a really good idea to include an indicator of this uncertainty on a plot. Typically, this is done by adding error bars to the means that show the 95% confidence interval. 

When we plotted a mean we added this layer to our plot:

```         
stat_summary(fun = "mean", geom = "point")
```

Basically we set the data to plot to be the function that returns the mean value (fun = "mean"), and the geom to be a point (geom = "point"). If we want to plot the 95% confidence interval around the mean both of these things change. The number of data points changes because for every mean we now want to plot three data points (the mean and the upper and lower limit of the corresponding confidence interval) instead of one (the mean). The geom changes because we can't plot three values using a single point.

To change the number of data points we use fun.data instead of fun, and instead of specifying mean we specify mean_cl_normal for a normal confidence interval or mean_cl_boot for a robust confidence interval based on a bootstrap. We change the geom to geom = "pointrange" which is a geom that shows a point with a line through it representing a range (in this case, the limits of the confidence interval).

These two adjustments are made within stat_summary():

```         
stat_summary(fun.data = "mean_cl_normal", geom = "pointrange")
```

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  geom_violin() +
  stat_summary(fun.data = "mean_cl_normal", geom = "pointrange", position = position_dodge(width = 0.9)) +
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  coord_cartesian(ylim = c(0, 100)) +
  scale_y_continuous(breaks = seq(0, 100, 10)) +
  theme_minimal()
```

For Bootstrap using facet_wrap() for example

```{r}
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  geom_violin() +
  stat_summary(fun.data = "mean_cl_boot", geom = "pointrange") +  
  labs(x = "Time", y = "Success (%)") +
  coord_cartesian(ylim = c(0, 70)) +
  scale_y_continuous(breaks = seq(0, 70, 10)) +
  facet_wrap(~strategy) +
  theme_minimal()
```

## Transfer Tasks

Imagine that a film company director was interested in whether there was really such a thing as a 'chick flick' (a film that has the stereotype of appealing to women more than to men). He took 20 men and 20 women and showed half of each sample a film that was supposed to be a 'chick flick' (The Notebook). The other half watched a documentary about notebooks as a control. In all cases the company director measured participants' emotional arousal as an indicator of how much they enjoyed the film. The data are in notebook_tib and contains three variables:

-   **sex**: the biological sex of the participant

-   **film**: whether they watched the notebook or a documentary about notebooks

-   **arousal**: the participant's emotional arousal during the film.

Plot a boxplot of the data that shows **sex** on the *x*-axis, and fills the boxplots in different colours for different films. Name the plot object note_plot.

```{r}
note_plot <- ggplot2::ggplot(notebook_tib, aes(sex, arousal, fill = film))
  note_plot +
    geom_boxplot()+
    labs(x = "Sex", y = "Arousal", fill = "Film shown") +
    coord_cartesian(ylim = c(0, 50)) +
    scale_y_continuous(breaks = seq(0, 50, 5)) +
    theme_minimal()
```

Plot a violin plot (with means) of the data that shows **sex** on the *x*-axis, and plots points and violins for different films in different colours. Name the plot object note_plot.

```{r}
note_plot <- ggplot2::ggplot(notebook_tib, aes(sex, arousal, fill = film))
  note_plot +
    geom_violin() +
    stat_summary(fun = "mean", geom = "point", size = 4, position = position_dodge(width = 0.9)) +  
    labs(x = "Sex", y = "Arousal", fill = "Film shown") +
    coord_cartesian(ylim = c(0, 50)) +
    scale_y_continuous(breaks = seq(0, 50, 5)) +
    theme_minimal()
```

## Scatterplots

A psychologist was interested in the effects of exam stress on exam performance. She devised and validated a questionnaire to assess state anxiety relating to exams (called the Exam Anxiety Questionnaire, or EAQ). This scale produced a measure of anxiety scored out of 100. Anxiety was measured before an exam, and the percentage mark of each student on the exam was used to assess the exam performance. The first thing that the psychologist should do is draw a scatterplot of the two variables. The data are in exam_tib, which contains 5 variables:

-   **id**: participant id

-   **revise**: the time spent revising for the exam (hours)

-   **exam_grade**: the percentage score of each student on the exam

-   **anxiety**: anxiety score on the EAQ out of 100

-   **sex**: biological sex of the participant

A scatterplot is just the values of one variable plotted on the *x*-axis, against the values of another on the *y*-axis.

If we wanted to plot **anxiety** on the *x*-axis and **exam_grade** on the *y* we could set this up in the usual way:

```         
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade))
```

This command creates an object called exam_plot using the data in exam_tib, and uses the `aes()` function to specify that **anxiety** is plotted on the *x*-axis and **exam_grade** on the *y*. We'd then need to simply add `geom_point()` to represent the data points:

```         
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade)) exam_plot +   geom_point()
```

```{r}
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade))
exam_plot +
  geom_point() +
  labs(x = "Anxiety reported", y = "Exam Grade (%)") +
  theme_bw()
```

### Changing the Appearance of Points

We can use the options of `geom_point()` to change the colour of the points, their size, their shape and their transparency. Many of these arguments work with other geoms too:

-   colour =: use this argument to specify a manual colour for the points

-   size =: use this argument to specify a size for the points

-   shape =: use this argument to specify a shape for the points

-   alpha =: use this argument to specify transparency from 0 (fully transparent) to 1 (fully opaque)

For colours it is useful to use hex codes.

We could also change the shape of the geom. Execute "?points" to get a list of shapes

```{r}
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade))
exam_plot +
  geom_point(colour = "#56B4E9", size = 4, shape = 17, alpha = 0.6) +
  labs(x = "Exam anxiety", y = "Exam mark (%)") +
  theme_bw()
```

### Summarizing the Trend

We can add a line summarizing the trend in the data using `geom_smooth()`. To fit a straight line we can set a method of "lm". By default, a confidence interval is plotted around the line.

```{r}
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade))
exam_plot +
  geom_point(colour = "#56B4E9", alpha = 0.6) +
  geom_smooth(method = "lm", colour = "#E69F00", fill = "#E69F00") +
  labs(x = "Exam anxiety", y = "Exam mark (%)") +
  theme_bw() 
```

### Grouped Scatterplots

If we wanted to compare the relationship between male and female students, we could do this by adding a facet:

```{r}
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade))
exam_plot +
  geom_point(colour = "#56B4E9", alpha = 0.6) +
  geom_smooth(method = "lm", colour = "#E69F00", fill = "#E69F00") +
  labs(x = "Exam anxiety", y = "Exam mark (%)") +
  facet_wrap(~sex) +
  theme_bw()  
```

We can also specify different colours for men and women using colour = sex when we set up the plot. To colour the interval around the line by sex, we'd also need to include fill = sex

```{r}
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade, colour = sex, fill = sex))
exam_plot +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm") +
  theme_minimal()
```

Colours specified in a `geom()` override the colour argument in the original `ggplot()` function. Therefore, if you set the colour by a variable such as **sex** in `ggplot()`you must delete any colour arguments in the geom itself for this to take effect.

```{r}
exam_plot <- ggplot2::ggplot(exam_tib, aes(anxiety, exam_grade, colour = sex, fill= sex))
exam_plot +
  geom_point(colour = "#56B4E9") +
  geom_smooth(method = "lm", colour = "#E69F00", fill = "#E69F00") +
  theme_minimal() 
```

## Methods Practice

For filled in plots

```{r}
# Using fill
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, fill = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)", fill = "Success strategy") +
  theme_minimal()
```

For coloured outer edges

```{r}
# Using colour
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  theme_minimal()
```

Facets

```{r}
# Using Facets
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)") +
  facet_wrap(~strategy) + 
  theme_minimal()
```

Facets and colour together. No need for legend so hide it.

```{r}
# Combination???
wish_plot <- ggplot2::ggplot(wish_tib, aes(time, success, colour = strategy))
wish_plot +
  geom_boxplot() +  
  labs(x = "Time", y = "Success (%)", colour = "Success strategy") +
  facet_wrap(~strategy) + 
  theme_minimal() + 
  # Gets rid of the legend and hides it. 
  theme(legend.position = "none")
```

# 
